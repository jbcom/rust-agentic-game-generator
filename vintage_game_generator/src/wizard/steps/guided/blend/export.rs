use crate::wizard::steps::guided::types::{GuidedModeExport, SourceGame};
use bevy_egui::egui;
use minijinja::{Environment, context};
use serde::Serialize;
use std::collections::HashMap;

/// Export blend result to a configuration format
pub fn export_blend_to_config(
    state: &crate::wizard::steps::guided::GuidedModeState,
) -> Option<GuidedModeExport> {
    let blend = state.blend_result.as_ref()?;

    // Convert source games from the blend path
    let source_games = blend
        .blend_path
        .games
        .iter()
        .filter_map(|game_id| {
            // game_id is a String, need to parse it to u32
            game_id.parse::<u32>().ok().and_then(|id| {
                state.selected_games.get(&id).map(|game| SourceGame {
                    name: game.name.to_string(),
                    year: game.year,
                    genre: game.genre.to_string(),
                    developer: game.developer.map(|s| s.to_string()),
                })
            })
        })
        .collect();

    Some(GuidedModeExport {
        blend_name: blend.name.clone(),
        description: blend.description.clone(),
        source_games,
        genre_weights: blend.genres.clone(),
        mechanics: blend.mechanics.iter().cloned().collect(),
        art_styles: blend.art_styles.clone(),
        complexity: blend.complexity_score,
        action_strategy_balance: blend.action_strategy_balance,
        recommended_features: blend.recommended_features.clone(),
    })
}

/// Export blend to TOML format
pub fn export_to_toml(state: &crate::wizard::steps::guided::GuidedModeState) -> Option<String> {
    let export = export_blend_to_config(state)?;

    let mut toml = String::new();

    // Header
    toml.push_str("# Vintage Game Blend Configuration\n");
    toml.push_str("# Generated by Vintage Game Generator\n\n");

    // Basic info
    toml.push_str("[blend]\n");
    toml.push_str(&format!("name = \"{}\"\n", export.blend_name));
    toml.push_str(&format!("description = \"{}\"\n", export.description));
    toml.push_str(&format!("complexity = {:.2}\n", export.complexity));
    toml.push_str(&format!(
        "action_strategy_balance = {:.2}\n\n",
        export.action_strategy_balance
    ));

    // Source games
    toml.push_str("[[source_games]]\n");
    for game in &export.source_games {
        toml.push_str(&format!("name = \"{}\"\n", game.name));
        toml.push_str(&format!("year = {}\n", game.year));
        toml.push_str(&format!("genre = \"{}\"\n", game.genre));
        if let Some(dev) = &game.developer {
            toml.push_str(&format!("developer = \"{dev}\"\n"));
        }
        toml.push('\n');
    }

    // Genre weights
    toml.push_str("[genres]\n");
    let mut sorted_genres: Vec<_> = export.genre_weights.iter().collect();
    sorted_genres.sort_by_key(|(name, _)| *name);
    for (genre, weight) in sorted_genres {
        toml.push_str(&format!(
            "{} = {:.2}\n",
            genre.to_lowercase().replace(' ', "_"),
            weight
        ));
    }
    toml.push('\n');

    // Mechanics
    toml.push_str("[mechanics]\n");
    for (i, mechanic) in export.mechanics.iter().enumerate() {
        toml.push_str(&format!("mechanic_{} = \"{}\"\n", i + 1, mechanic));
    }
    toml.push('\n');

    // Art styles
    toml.push_str("[art]\n");
    toml.push_str("styles = [\n");
    for style in &export.art_styles {
        toml.push_str(&format!("  \"{style}\",\n"));
    }
    toml.push_str("]\n\n");

    // Recommendations
    toml.push_str("[features]\n");
    toml.push_str("recommended = [\n");
    for feature in &export.recommended_features {
        toml.push_str(&format!("  \"{feature}\",\n"));
    }
    toml.push_str("]\n");

    Some(toml)
}

/// Export blend to JSON format
pub fn export_to_json(
    state: &crate::wizard::steps::guided::GuidedModeState,
) -> Option<serde_json::Value> {
    let export = export_blend_to_config(state)?;
    let blend = state.blend_result.as_ref()?;

    Some(serde_json::json!({
        "blend": {
            "name": export.blend_name,
            "description": export.description,
            "complexity": export.complexity,
            "action_strategy_balance": export.action_strategy_balance,
        },
        "source_games": export.source_games,
        "genres": export.genre_weights,
        "mechanics": export.mechanics,
        "art_styles": export.art_styles,
        "recommended_features": export.recommended_features,
        "synergies": blend.synergies.iter().map(|s| {
            serde_json::json!({
                "games": [s.game1.clone(), s.game2.clone()],
                "description": s.description,
                "strength": s.strength
            })
        }).collect::<Vec<_>>(),
        "conflicts": blend.conflicts.iter().map(|c| {
            serde_json::json!({
                "games": [c.game1.clone(), c.game2.clone()],
                "type": c.conflict_type,
                "resolution": c.resolution
            })
        }).collect::<Vec<_>>(),
    }))
}

/// Generate a prompt for AI based on the blend using minijinja templates
pub fn generate_ai_prompt(
    state: &crate::wizard::steps::guided::GuidedModeState,
) -> anyhow::Result<String> {
    let blend = state
        .blend_result
        .as_ref()
        .ok_or_else(|| anyhow::anyhow!("No blend result available"))?;
    let export =
        export_blend_to_config(state).ok_or_else(|| anyhow::anyhow!("Failed to export config"))?;

    let mut env = Environment::new();

    // Load the blend game design template
    let template_content = std::fs::read_to_string("metaprompts/blend_game_design.jinja")
        .or_else(|_| {
            std::fs::read_to_string(
                "crates/vintage_game_generator/metaprompts/blend_game_design.jinja",
            )
        })
        .map_err(|e| anyhow::anyhow!("Failed to load blend template: {e}"))?;

    env.add_template_owned("blend_game_design", template_content)?;

    // Render the template
    let tmpl = env.get_template("blend_game_design")?;

    // Need to make BlendResult serializable for the template
    #[derive(Serialize)]
    struct SerializableBlend {
        name: String,
        description: String,
        genres: HashMap<String, f32>,
        mechanics: Vec<String>,
        art_styles: Vec<String>,
        complexity_score: f32,
        synergies: Vec<SerializableSynergy>,
        conflicts: Vec<SerializableConflict>,
    }

    #[derive(Serialize)]
    struct SerializableSynergy {
        game1: String,
        game2: String,
        description: String,
        strength: f32,
    }

    #[derive(Serialize)]
    struct SerializableConflict {
        game1: String,
        game2: String,
        conflict_type: String,
        resolution: String,
    }

    let serializable_blend = SerializableBlend {
        name: blend.name.clone(),
        description: blend.description.clone(),
        genres: blend.genres.clone(),
        mechanics: blend.mechanics.iter().cloned().collect(),
        art_styles: blend.art_styles.clone(),
        complexity_score: blend.complexity_score,
        synergies: blend
            .synergies
            .iter()
            .map(|s| SerializableSynergy {
                game1: s.game1.clone(),
                game2: s.game2.clone(),
                description: s.description.clone(),
                strength: s.strength,
            })
            .collect(),
        conflicts: blend
            .conflicts
            .iter()
            .map(|c| SerializableConflict {
                game1: c.game1.clone(),
                game2: c.game2.clone(),
                conflict_type: c.conflict_type.clone(),
                resolution: c.resolution.clone(),
            })
            .collect(),
    };

    let rendered = tmpl.render(context!(
        blend => serializable_blend,
        source_games => export.source_games
    ))?;

    Ok(rendered)
}

/// Export UI for showing export options
pub fn render_export_ui(ui: &mut egui::Ui, state: &crate::wizard::steps::guided::GuidedModeState) {
    ui.heading("ðŸ“¤ Export Options");
    ui.separator();

    if state.blend_result.is_none() {
        ui.label("No blend result to export. Create a blend first!");
        return;
    }

    ui.horizontal(|ui| {
        if ui.button("ðŸ“„ Copy TOML").clicked()
            && let Some(toml) = export_to_toml(state)
        {
            // TODO: Copy to clipboard
            ui.ctx().copy_text(toml);
        }

        if ui.button("ðŸ“‹ Copy JSON").clicked()
            && let Some(json) = export_to_json(state)
        {
            // TODO: Copy to clipboard
            ui.ctx().copy_text(json.to_string());
        }

        if ui.button("ðŸ¤– Copy AI Prompt").clicked() {
            match generate_ai_prompt(state) {
                Ok(prompt) => {
                    ui.ctx().copy_text(prompt);
                }
                Err(e) => {
                    eprintln!("Failed to generate AI prompt: {e}");
                }
            }
        }
    });

    // Show export preview
    ui.separator();
    ui.collapsing("Preview TOML Export", |ui| {
        if let Some(toml) = export_to_toml(state) {
            ui.monospace(&toml);
        }
    });
}
