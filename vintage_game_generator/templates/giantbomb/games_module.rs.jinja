//! Vintage game timeline module ({{ timeline_start }}-{{ timeline_end }})
//! 
//! This module contains a curated timeline of exemplar games from the golden and retro eras.
//! Each year features the highest-rated game from up to 3 different genres.
//! Games are selected to serve as creative inspiration for the AI RPG generator.
//!
//! Platform information is included to provide context about technical constraints
//! and creative solutions that shaped these classic games.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimelineGame {
    pub id: u32,
    pub year: i32,
    pub genre: &'static str,
    pub name: &'static str,
    pub deck: Option<&'static str>,
    pub platforms: Vec<&'static str>,
    pub developer: Option<&'static str>,
    pub image_url: Option<&'static str>,
    pub site_url: &'static str,
}

/// Timeline of exemplar games organized by year and genre
pub const TIMELINE_GAMES: &[TimelineGame] = &[
{%- for game in games %}
    TimelineGame {
        id: {{ game.id }},
        year: {{ game.year }},
        genre: r#"{{ game.genre }}"#,
        name: r#"{{ game.name }}"#,
        deck: {% if game.deck %}Some(r#"{{ game.deck }}"#){% else %}None{% endif %},
        platforms: vec![
            {%- for platform in game.platforms %}
            r#"{{ platform }}"#{% if not loop.last %},{% endif %}
            {%- endfor %}
        ],
        developer: {% if game.developers %}Some(r#"{{ game.developers }}"#){% else %}None{% endif %},
        image_url: {% if game.image_url %}Some(r#"{{ game.image_url }}"#){% else %}None{% endif %},
        site_url: r#"{{ game.site_url }}"#,
    }{% if not loop.last %},{% endif %}
{%- endfor %}
];

/// Timeline span
pub const TIMELINE_START: i32 = {{ timeline_start }};
pub const TIMELINE_END: i32 = {{ timeline_end }};

/// Get games for a specific year
pub fn games_by_year(year: i32) -> Vec<&'static TimelineGame> {
    TIMELINE_GAMES.iter()
        .filter(|game| game.year == year)
        .collect()
}

/// Get games for a specific genre across all years
pub fn games_by_genre(genre: &str) -> Vec<&'static TimelineGame> {
    let genre_lower = genre.to_lowercase();
    TIMELINE_GAMES.iter()
        .filter(|game| game.genre.to_lowercase() == genre_lower)
        .collect()
}

/// Get all unique genres in the timeline
pub fn all_genres() -> Vec<String> {
    let mut genres: Vec<String> = TIMELINE_GAMES.iter()
        .map(|game| game.genre.to_string())
        .collect::<std::collections::HashSet<_>>()
        .into_iter()
        .collect();
    genres.sort();
    genres
}

/// Get all years that have games
pub fn timeline_years() -> Vec<i32> {
    let mut years: Vec<i32> = TIMELINE_GAMES.iter()
        .map(|game| game.year)
        .collect::<std::collections::HashSet<_>>()
        .into_iter()
        .collect();
    years.sort();
    years
}

/// Build a year-to-games index for efficient timeline navigation
pub fn build_timeline_index() -> HashMap<i32, Vec<&'static TimelineGame>> {
    let mut index: HashMap<i32, Vec<&'static TimelineGame>> = HashMap::new();
    
    for game in TIMELINE_GAMES.iter() {
        index.entry(game.year)
            .or_insert_with(Vec::new)
            .push(game);
    }
    
    index
}

/// Get a random exemplar game (useful for inspiration)
pub fn random_exemplar() -> &'static TimelineGame {
    // Use a simple deterministic "random" based on current time
    let index = (std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs() as usize) % TIMELINE_GAMES.len();
    
    &TIMELINE_GAMES[index]
}

/// Find games that match a search query
pub fn search_games(query: &str) -> Vec<&'static TimelineGame> {
    let query_lower = query.to_lowercase();
    TIMELINE_GAMES.iter()
        .filter(|game| {
            game.name.to_lowercase().contains(&query_lower) ||
            game.genre.to_lowercase().contains(&query_lower) ||
            game.deck.as_ref().map_or(false, |d| d.to_lowercase().contains(&query_lower))
        })
        .collect()
}

/// Get games from a specific era
pub fn games_by_era(era: Era) -> Vec<&'static TimelineGame> {
    let (start, end) = match era {
        Era::ArcadeGoldenAge => (1980, 1983),
        Era::EarlyConsole => (1984, 1987),
        Era::Late8BitEarly16 => (1988, 1991),
        Era::Peak16Bit => (1992, 1995),
    };
    
    TIMELINE_GAMES.iter()
        .filter(|game| game.year >= start && game.year <= end)
        .collect()
}

/// Get era for a given year
pub fn era_for_year(year: i32) -> Option<Era> {
    match year {
        1980..=1983 => Some(Era::ArcadeGoldenAge),
        1984..=1987 => Some(Era::EarlyConsole),
        1988..=1991 => Some(Era::Late8BitEarly16),
        1992..=1995 => Some(Era::Peak16Bit),
        _ => None,
    }
}

/// Get a description of what makes each era special
pub fn era_description(era: Era) -> &'static str {
    match era {
        Era::ArcadeGoldenAge => "Simple, focused gameplay with emerging genres. Technical constraints led to creative solutions.",
        Era::EarlyConsole => "Home consoles arrive, genres solidify. RPGs emerge with Dragon Quest and Zelda.",
        Era::Late8BitEarly16 => "Refined 8-bit masterpieces meet early 16-bit innovation. Peak creativity within constraints.",
        Era::Peak16Bit => "Genre perfection with 2D art at its finest. The golden age of sprite-based games.",
    }
}

#[derive(Debug, Clone, Copy)]
pub enum Era {
    ArcadeGoldenAge, // 1980-1983
    EarlyConsole,    // 1984-1987  
    Late8BitEarly16, // 1988-1991
    Peak16Bit,       // 1992-1995
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlatformInfo {
    pub id: u32,
    pub name: &'static str,
    pub abbreviation: Option<&'static str>,
    pub deck: Option<&'static str>,
    pub install_base: Option<u64>,
    pub original_price: Option<&'static str>,
    pub release_date: Option<&'static str>,
    pub online_support: Option<bool>,
}

/// Platform information for correlation and context
pub const PLATFORM_INFO: &[PlatformInfo] = &[
{%- for platform in platforms %}
    PlatformInfo {
        id: {{ platform.id }},
        name: r#"{{ platform.name }}"#,
        abbreviation: {% if platform.abbreviation %}Some(r#"{{ platform.abbreviation }}"#){% else %}None{% endif %},
        deck: {% if platform.deck %}Some(r#"{{ platform.deck }}"#){% else %}None{% endif %},
        install_base: {% if platform.install_base %}Some({{ platform.install_base }}){% else %}None{% endif %},
        original_price: {% if platform.original_price %}Some(r#"{{ platform.original_price }}"#){% else %}None{% endif %},
        release_date: {% if platform.release_date %}Some(r#"{{ platform.release_date }}"#){% else %}None{% endif %},
        online_support: {% if platform.online_support %}Some({{ platform.online_support }}){% else %}None{% endif %},
    }{% if not loop.last %},{% endif %}
{%- endfor %}
];

/// Get platform info by name
pub fn get_platform_info(name: &str) -> Option<&'static PlatformInfo> {
    PLATFORM_INFO.iter()
        .find(|p| p.name.eq_ignore_ascii_case(name) || 
                  p.abbreviation.as_ref().map_or(false, |abbr| abbr.eq_ignore_ascii_case(name)))
}

/// Group games by their primary platform
pub fn games_by_platform() -> HashMap<String, Vec<&'static TimelineGame>> {
    let mut platform_games: HashMap<String, Vec<&'static TimelineGame>> = HashMap::new();
    
    for game in TIMELINE_GAMES.iter() {
        if let Some(platform) = game.platforms.first() {
            platform_games.entry(platform.to_string())
                .or_insert_with(Vec::new)
                .push(game);
        }
    }
    
    platform_games
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_timeline_integrity() {
        assert!(!TIMELINE_GAMES.is_empty());
        assert!(TIMELINE_GAMES.iter().all(|g| g.year >= TIMELINE_START && g.year <= TIMELINE_END));
    }

    #[test]
    fn test_year_filtering() {
        let years = timeline_years();
        assert!(!years.is_empty());
        assert!(years.windows(2).all(|w| w[0] < w[1])); // Sorted
    }
}
